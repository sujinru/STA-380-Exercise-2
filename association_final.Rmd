---

output: md_document
---

```{r}
library(arules)
library(pander)
```

**Processing Data**

Initialize the dataframe to be processed by the apriori algorithm
```{r}
itemlists <- data.frame(0,0)
names(itemlists) <- c("num","item")
```

Read each line and tag transaction numbers to each item
```{r}
#Keep track of the number of line(transaction)

trans = 0
for(line in readLines("groceries.txt")){
    trans = trans + 1
    basket <- unlist(strsplit(line,","))
    for(i in 1:length(basket)){
        if((trans == 1) & (i == 1)){
            itemlists[1,] <- c(trans, basket[i])
        }
        else{itemlists <- rbind(itemlists, c(trans, basket[i]))}
    }
}
```

Turn number of transaction into a factor
```{r}
itemlists$num <- factor(itemlists$num)
pander(head(itemlists))
```

The table above shows the head of transaction dataframe before splitting it by transactions.

apriori algorithm expects a list of baskets in a special format
In this case, one "transaction" of items per user
First split data into a list of items for each transaction
```{r}
transactions <- split(x=itemlists$item, f=itemlists$num)
length(transactions)
```

There are 9835 transactions.

```{r}
## Remove duplicates 
transactions <- lapply(transactions, unique)
```


```{r}
## Cast this variable as a special arules "transactions" class.
transactions <- as(transactions, "transactions")
```


**Applying Apriori Algorithm**

Now run the 'apriori' algorithm
```{r}
basketrules <- apriori(transactions, parameter=list(support=.001, confidence=.5, maxlen=10))
inspect(head(sort(basketrules, by="lift"),20))
```

**Choice of parameters**

We chose support= 0.001 because higher levels of support gave too few rules for us to inspect. We chose confidence = 0.5 because we want to make sure that if iem on rhs appears, item on lhs will also appear. However, this only accounts for how popular the items on rhs are, but not those on the lhs. If rhs items appear regularly in general, there is a greater chance that items on the rhs will contain items on the lhs. To account for this bias, we select our final itemlists based on lift since lift measures how likely item on lhs is purchased when item rhs is purchased. Therefore, we sort the items by lift and rank the top 20 rules, which is the result generated by the algorithm.

**Recommendation**

Our final result also makes sense. With this insight, we can give this to information to store managers to help plan inventory for these perishable items. Also, this information can be used for product placement strategy. For example, store manager can put ham, cheese, and white bread near each other to stimulate more sales